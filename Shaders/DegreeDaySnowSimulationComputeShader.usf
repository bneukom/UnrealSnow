#include "Common.usf"

struct SimulationCell
{
	float Aspect;
	float Inclination;
	float Altitude;
	float Latitude;
	float Area;
	float AreaXY;
	float SnowWaterEquivalent;
	float SnowAlbedo;
	float DaysSinceLastSnowfall;
	float Curvature;


};

struct WeatherData
{
	float Temperature;
	float Precipitation;
};

RWTexture2D<uint> OutputSurface;
RWStructuredBuffer<SimulationCell> SimulationCellsBuffer;
RWStructuredBuffer<WeatherData> WeatherDataBuffer;
RWStructuredBuffer<uint> MaxSnowBuffer;

// sunrise/sunset
float Func2(float L, float D) 
{
	return acos(clamp(-tan(L) * tan(D), -1.0f, 1.0f));
}

// radiation
float Func3(float V, float W, float X, float Y, float R1, float D) 
{
	return R1 * (sin(D) * sin(W) * (X - Y) * (12 / PI) + 
		cos(D) * cos(W) * (sin(X + V) - sin(Y + V)) * (12 / PI));
}

/**
* Calculates the solar radiation as described in Swifts "Algorithm for Solar Radiation on Mountain Slopes".
*
* @param I		The inclination of the slope in radians.
* @param A		The aspect (compass direction) that the slope faces in radians.
* @param L0		The latitude of the slope in radians.
*/
float SolarRadiationIndex(float I, float A, float L0, float J)
{
	float L1 = asin(cos(I) * sin(L0) + sin(I) * cos(L0) * cos(A));
	float D1 = cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A);
	float L2 = atan((sin(I) * sin(A)) / (cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A)));

	float D = 0.007 - 0.4067 * cos((J + 10) * 0.0172);
	float E = 1.0 - 0.0167 * cos((J - 3) * 0.0172);

	const float R0 = 1.95;
	float R1 = 60 * R0 / (E * E);
	// float R1 = (PI / 3) * R0 / (E * E);

	float T;

	T = Func2(L1, D);
	float T7 = T - L2;
	float T6 = -T - L2;
	T = Func2(L0, D);
	float T1 = T;
	float T0 = -T;
	float T3 = min(T7, T1);
	float T2 = max(T6, T0);

	float T4 = T2 * (12 / PI);
	float T5 = T3 * (12 / PI);

	//float R4 = Func3(L2, L1, T3, T2, R1, D); // Figure1
	if (T3 < T2) // Figure2
	{
		T2 = T3 = 0;
	}

	T6 = T6 + PI * 2;

	float R4;
	if (T6 < T1)
	{
		float T8 = T6;
		float T9 = T1;
		R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);
	} 
	else
	{
		T7 = T7 - PI * 2;

		if (T7 > T0)
		{
			float T8 = T0;
			float T9 = T0;
			R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);
		}
		else
		{
			R4 = Func3(L2, L1, T3, T2, R1, D);
		}
	}

	float R3 = Func3(0.0, L0, T1, T0, R1, D);

	return R4 / R3;
}


[numthreads(4, 4, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	uint cellIndex = ThreadId.x + ThreadId.y * CSConstants.ThreadGroupCountX;
	uint cellIndexX = cellIndex % CSConstants.CellsDimension;
	uint cellIndexY = cellIndex / CSConstants.CellsDimension;

	uint weatherIndexX = (float)(cellIndexX / (float)CSConstants.CellsDimension * CSConstants.WeatherDataResolution);
	uint weatherIndexY = (float)(cellIndexY / (float)CSConstants.CellsDimension * CSConstants.WeatherDataResolution);
	uint weatherIndex = weatherIndexX + weatherIndexY * CSConstants.WeatherDataResolution;

	SimulationCell cell = SimulationCellsBuffer[cellIndex];
	WeatherData weatherData = WeatherDataBuffer[weatherIndex];
		
	float decay = -0.9f * SimulationCellsBuffer[cellIndex].Altitude / (100 * 100);
	float tAir = weatherData.Temperature + decay; // degree Celsius
	float precipitation = weatherData.Precipitation;
			
	// @TODO use AreaXY because very steep slopes with big areas would receive too much snow
	const float areaSquareMeters = SimulationCellsBuffer[cellIndex].AreaXY / (100 * 100); // m^2

	// Apply precipitation
	if (precipitation > 0)
	{
		SimulationCellsBuffer[cellIndex].DaysSinceLastSnowfall = 0;

		// New snow/rainfall
		bool rain = tAir > CSConstants.TSnowB;

		if (tAir > CSConstants.TSnowB)
		{
			SimulationCellsBuffer[cellIndex].SnowAlbedo = 0.4; // New rain drops the albedo to 0.4
		}
		else 
		{
			// Variable lapse rate as described in "A variable lapse rate snowline model for the Remarkables, Central Otago, New Zealand"
			float snowRate = clamp(1 - (tAir - CSConstants.TSnowA) / (CSConstants.TSnowB - CSConstants.TSnowA), 0.0f, 1.0f);

			SimulationCellsBuffer[cellIndex].SnowWaterEquivalent += (precipitation * areaSquareMeters * snowRate); // l/m^2 * m^2 = l
			SimulationCellsBuffer[cellIndex].SnowAlbedo = 0.8; // New snow sets the albedo to 0.8
		}
	}

	// Apply melt
	if (SimulationCellsBuffer[cellIndex].SnowWaterEquivalent > 0)
	{
		if (SimulationCellsBuffer[cellIndex].DaysSinceLastSnowfall >= 0) {
			// @TODO is time T the degree-days or the time since the last snowfall?
			SimulationCellsBuffer[cellIndex].SnowAlbedo = 0.4 * (1 + exp(-CSConstants.k_e * SimulationCellsBuffer[cellIndex].DaysSinceLastSnowfall)); 
		}

		// Temperature higher than melt threshold and cell contains snow
		if (tAir > CSConstants.TMeltA)
		{
			const float dayNormalization = 24.0 / 1.0; // day 

			// Radiation Index
			const float R_i = SolarRadiationIndex(SimulationCellsBuffer[cellIndex].Inclination, SimulationCellsBuffer[cellIndex].Aspect, SimulationCellsBuffer[cellIndex].Latitude, CSVariables.DayOfYear); // 1

			// Melt factor
			const float vegetationDensity = 0;
			const float k_v = exp(-4 * vegetationDensity); // 1
			const float c_m = CSConstants.k_m * k_v * R_i *  (1 - SimulationCellsBuffer[cellIndex].SnowAlbedo) * dayNormalization * areaSquareMeters; // l/m^2/C°/day * day * m^2 = l/m^2 * 1/day * day * m^2 = l/C°
			const float M = c_m * clamp((tAir - CSConstants.TMeltA) / (CSConstants.TMeltB - CSConstants.TMeltA), 0.0f, 1.0f); // l/C° * C° = l

			// Apply melt
			SimulationCellsBuffer[cellIndex].SnowWaterEquivalent -= M; 
			SimulationCellsBuffer[cellIndex].SnowWaterEquivalent = max(0.0f, SimulationCellsBuffer[cellIndex].SnowWaterEquivalent);
		}
	}

	SimulationCellsBuffer[cellIndex].DaysSinceLastSnowfall += 1.0f / 24.0f;

	float slope = degrees(SimulationCellsBuffer[cellIndex].Inclination);

	float f = slope < 15 ? 0 : slope / 80;
	float a3 = 50;
	float we = max(0.0f, SimulationCellsBuffer[cellIndex].SnowWaterEquivalent * (1 - f) * (1 + a3 * SimulationCellsBuffer[cellIndex].Curvature));

	// Find global max
	InterlockedMax(MaxSnowBuffer[0], asuint(we * 100000));

	// Write to texture
	uint r =  (uint) we * 255.0;
	uint g = ((uint)(we * 255.0)) << 8;
	uint b = ((uint)(we * 255.0)) << 16;
	uint a = ((uint)(255.0))	  << 24;
	OutputSurface[ThreadId.xy] = r | g | b | a;

}


