#include "Common.usf"

// Base shader origin:
// https://www.shadertoy.com/view/MdXSzS
// The Big Bang - just a small explosion somewhere in a massive Galaxy of Universes.
// Outside of this there's a massive galaxy of 'Galaxy of Universes'... etc etc. :D
//
// HLSL translation and parameterization by Temaran

/**
Uniform Buffers

//This buffer should contain variables that never, or rarely change
BEGIN_UNIFORM_BUFFER_STRUCT(FComputeShaderConstantParameters, )
DECLARE_UNIFORM_BUFFER_STRUCT_MEMBER(float, SimulationSpeed)
END_UNIFORM_BUFFER_STRUCT(FComputeShaderConstantParameters)

//This buffer is for variables that change very often (each frame for example)
BEGIN_UNIFORM_BUFFER_STRUCT(FComputeShaderVariableParameters, )
DECLARE_UNIFORM_BUFFER_STRUCT_MEMBER(float, TotalTimeElapsedSeconds)
END_UNIFORM_BUFFER_STRUCT(FComputeShaderVariableParameters)
*/

RWTexture2D<uint> OutputSurface;

[numthreads(32, 32, 1)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	uint r = 255.0;
	uint g = ((uint)(255)) << 8;
	uint b = ((uint)(255)) << 16;
	uint a = ((uint)(255)) << 24;

	OutputSurface[ThreadId.xy] = r | g | b | a;
}

/**
* Calculates the solar radiation as described in Swifts "Algorithm for Solar Radiation on Mountain Slopes".
*
* @param I		The inclination of the slope in radians.
* @param A		The aspect (compass direction) that the slope faces in radians.
* @param L0		The latitude of the slope in radians.
*/
float SolarRadiationIndex(float I, float A, float L0, float J)
{
	float L1 = asin(cos(I) * sin(L0) + sin(I) * cos(L0) * cos(A));
	float D1 = cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A);
	float L2 = FMath::Atan((sin(I) * sin(A)) / (cos(I) * cos(L0) - sin(I) * sin(L0) * cos(A)));

	float D = 0.007 - 0.4067 * cos((J + 10) * 0.0172);
	float E = 1.0 - 0.0167 * cos((J - 3) * 0.0172);

	const float R0 = 1.95;
	float R1 = 60 * R0 / (E * E);
	// float R1 = (PI / 3) * R0 / (E * E);

	float T;

	T = Func2(L1, D);
	float T7 = T - L2;
	float T6 = -T - L2;
	T = Func2(L0, D);
	float T1 = T;
	float T0 = -T;
	float T3 = min(T7, T1);
	float T2 = max(T6, T0);

	float T4 = T2 * (12 / PI);
	float T5 = T3 * (12 / PI);

	//float R4 = Func3(L2, L1, T3, T2, R1, D); // Figure1
	if (T3 < T2) // Figure2
	{
		T2 = T3 = 0;
	}

	T6 = T6 + PI * 2;

	float R4;
	if (T6 < T1)
	{
		float T8 = T6;
		float T9 = T1;
		R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);
	} 
	else
	{
		T7 = T7 - PI * 2;

		if (T7 > T0)
		{
			float T8 = T0;
			float T9 = T0;
			R4 = Func3(L2, L1, T3, T2, R1, D) + Func3(L2, L1, T9, T8, R1, D);
		}
		else
		{
			R4 = Func3(L2, L1, T3, T2, R1, D);
		}
	}

	float R3 = Func3(0.0, L0, T1, T0, R1, D);

	return R4 / R3;
}

// @TODO check for invalid latitudes (90°)
float Func2(float L, float D) // sunrise/sunset
{
	return acos(clamp(-tan(L) * tan(D), -1.0f, 1.0f));
}

float Func3(float V, float W, float X, float Y, float R1, float D) // radiation
{
	return R1 * (sin(D) * sin(W) * (X - Y) * (12 / PI) + 
		cos(D) * cos(W) * (sin(X + V) - sin(Y + V)) * (12 / PI));
}